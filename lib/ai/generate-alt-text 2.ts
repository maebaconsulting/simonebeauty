/**
 * AI Alt-Text Generation
 * Feature: 017-image-management
 *
 * Generate accessible alt-text for images using OpenAI GPT-4 Vision API
 */

import { getOpenAIClient, isOpenAIConfigured } from './openai-client'
import type { EntityType } from '@/lib/validations/image-schemas'

export interface GenerateAltTextOptions {
  /**
   * Public URL of the image to analyze
   */
  imageUrl: string

  /**
   * Entity type for context
   */
  entityType: EntityType

  /**
   * Optional entity name for additional context
   * e.g., "Coiffure professionnelle", "Vernis à ongles rouge"
   */
  entityName?: string

  /**
   * Maximum length of generated alt-text (default: 125 chars, WCAG recommendation)
   */
  maxLength?: number
}

export interface GenerateAltTextResult {
  /**
   * Generated alt-text in French
   */
  altText: string

  /**
   * Model used for generation
   */
  model: string

  /**
   * Whether a fallback was used (if OpenAI failed)
   */
  isFallback: boolean
}

/**
 * Generate alt-text for an image using OpenAI GPT-4 Vision
 *
 * @param options - Generation options
 * @returns Generated alt-text result
 */
export async function generateAltText(
  options: GenerateAltTextOptions
): Promise<GenerateAltTextResult> {
  const { imageUrl, entityType, entityName, maxLength = 125 } = options

  // Check if OpenAI is configured
  if (!isOpenAIConfigured()) {
    console.warn('OpenAI not configured, using fallback alt-text generation')
    return generateFallbackAltText(entityType, entityName, maxLength)
  }

  try {
    const openai = getOpenAIClient()

    // Construct prompt with context
    const prompt = buildPrompt(entityType, entityName, maxLength)

    // Call GPT-4 Vision API
    const response = await openai.chat.completions.create({
      model: 'gpt-4-vision-preview',
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: prompt,
            },
            {
              type: 'image_url',
              image_url: {
                url: imageUrl,
                detail: 'low', // Use 'low' for faster processing and lower cost
              },
            },
          ],
        },
      ],
      max_tokens: 100,
      temperature: 0.3, // Lower temperature for more consistent, factual descriptions
    })

    const generatedText = response.choices[0]?.message?.content?.trim()

    if (!generatedText) {
      throw new Error('No text generated by OpenAI')
    }

    // Ensure length constraint
    const truncatedText = truncateAltText(generatedText, maxLength)

    return {
      altText: truncatedText,
      model: response.model,
      isFallback: false,
    }
  } catch (error) {
    console.error('OpenAI alt-text generation failed:', error)

    // Fall back to simple generation
    return generateFallbackAltText(entityType, entityName, maxLength)
  }
}

/**
 * Build prompt for GPT-4 Vision based on entity type
 */
function buildPrompt(
  entityType: EntityType,
  entityName?: string,
  maxLength: number = 125
): string {
  const baseInstructions = `Génère un alt-text descriptif en français pour cette image.
L'alt-text doit:
- Décrire l'image de manière concise et factuelle
- Être accessible aux utilisateurs malvoyants
- Faire maximum ${maxLength} caractères
- Ne pas commencer par "Image de" ou "Photo de"
- Se terminer par " - Simone Paris"`

  const contextMap: Record<EntityType, string> = {
    service: entityName
      ? `Cette image représente un service: ${entityName}. Décris ce que montre l'image en relation avec ce service.`
      : 'Cette image représente un service de beauté. Décris ce que montre l\'image.',
    product: entityName
      ? `Cette image représente un produit: ${entityName}. Décris le produit visible dans l\'image.`
      : 'Cette image représente un produit de beauté. Décris le produit.',
    product_variant: entityName
      ? `Cette image montre une variation d'un produit: ${entityName}. Décris la variation spécifique (couleur, taille, etc.).`
      : 'Cette image montre une variation de produit. Décris ce qui la distingue.',
    conversation: 'Cette image a été partagée par un client dans une conversation. Décris objectivement ce que montre l\'image.',
  }

  return `${baseInstructions}\n\n${contextMap[entityType]}`
}

/**
 * Generate fallback alt-text when OpenAI is unavailable
 */
function generateFallbackAltText(
  entityType: EntityType,
  entityName?: string,
  maxLength: number = 125
): GenerateAltTextResult {
  let altText: string

  if (entityName) {
    altText = `${entityName} - Simone Paris`
  } else {
    const fallbackMap: Record<EntityType, string> = {
      service: 'Service de beauté - Simone Paris',
      product: 'Produit de beauté - Simone Paris',
      product_variant: 'Variation de produit - Simone Paris',
      conversation: 'Photo client - Simone Paris',
    }
    altText = fallbackMap[entityType]
  }

  // Ensure length constraint
  altText = truncateAltText(altText, maxLength)

  return {
    altText,
    model: 'fallback',
    isFallback: true,
  }
}

/**
 * Truncate alt-text to specified length while preserving word boundaries
 */
function truncateAltText(text: string, maxLength: number): string {
  if (text.length <= maxLength) {
    return text
  }

  // Try to truncate at last word boundary before maxLength
  const truncated = text.substring(0, maxLength)
  const lastSpaceIndex = truncated.lastIndexOf(' ')

  if (lastSpaceIndex > maxLength * 0.8) {
    // If last space is reasonably close to max length, use it
    return truncated.substring(0, lastSpaceIndex) + '...'
  }

  // Otherwise, hard truncate
  return truncated.substring(0, maxLength - 3) + '...'
}

/**
 * Batch generate alt-text for multiple images
 * Useful for bulk operations (e.g., migration of existing images)
 *
 * @param images - Array of image data with URLs
 * @param options - Common options for all images
 * @param concurrency - Max concurrent requests (default: 5 to avoid rate limits)
 * @returns Array of results
 */
export async function generateAltTextBatch(
  images: Array<{
    imageUrl: string
    entityType: EntityType
    entityName?: string
  }>,
  options: { maxLength?: number } = {},
  concurrency: number = 5
): Promise<GenerateAltTextResult[]> {
  const results: GenerateAltTextResult[] = []

  // Process in batches to respect rate limits
  for (let i = 0; i < images.length; i += concurrency) {
    const batch = images.slice(i, i + concurrency)
    const batchResults = await Promise.all(
      batch.map((img) =>
        generateAltText({
          imageUrl: img.imageUrl,
          entityType: img.entityType,
          entityName: img.entityName,
          maxLength: options.maxLength,
        })
      )
    )
    results.push(...batchResults)

    // Add delay between batches to avoid rate limiting (OpenAI: 500 req/min)
    if (i + concurrency < images.length) {
      await new Promise((resolve) => setTimeout(resolve, 1000))
    }
  }

  return results
}
